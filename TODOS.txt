TODOS:
------

WEB & SYS:
----------
1º   RB  ---- SSL conection (In RBPI2)
2º  DONE ---- Create scp daemon from server post method, se le pasan args como user, host etc... y pide por raw input la contraseña
3º       ---- Backup daemon/crontab --> integrar con scp o por separado || lo primero es bloqueante
4º  DONE ---- Check data in server and client (+- done)
5º  DONE ---- conectar post de frecuencia de mediciones con sensor (In PBPI2)
6º  DONE ---- Refactor
7º  DONE ---- HTML configuration with a "Correctly done." msg.
8º  FAIL ---- Js libraries get from RPI2 instead unknown server --> Google no permite su descarga.
9º  DONE ---- Responsive view
10º DONE ---- Implementar sesión

DETALLES:
---------
1º  DONE ---- raw_input imprime password varias veces, eliminar label del raw_input.
2º       ---- comprobar que el raw input realmente no almacena nada.
3º  DONE ---- sensor tiene que hacer un prepend al fichero no un append.
4º       ---- el post a configuracion se hace validando con 0 como valor minimo, mirar si subir ese minimo o si poner máximo.
5º  DONE ---- comprobar que la conexion scp se realizo correctamente.
6º       ---- cntl+c cerrar hacer popen con daemon stop para que se pare tambien (pensar antes si esto seria correcto).
7º       ---- si el scp casca enviar todos los archivos que no se enviaron // comprobar si el daemon sigue si el scp ha cascado.
8º       ---- Preguntar al usuario si esta seguro en los formularios cuando los valores sean ridiculos pero posibles, diciendo que la            bateria se acabara antes etc.
9º  DONE ---- Implementar autenticacion. Almacenando user y contraseña en dispositivo.
10º DONE ---- Pantalla de fallo en el login.
11º      ---- Comprobar que las cookies se borran correctamente.
12º DONE ---- Crear valor de cookie aleatoreo y diferente cada vez.
13º	DONE ---- Cookie gard doesnt work, find another form to ensure cookie exist
14º DONE ---- si no hay samples casca al intentar enseñar la web
15º DONE ---- añadir información sobre el user a la cookie generada para garantizar aleatoreidad
16º      ---- ir generando nuevos archivos en funcion del numero de muestras --> el generar la web necesitará algo más de lógica
17º      ---- comprobar cookies falsas, en las que se pueda haber cambiado la fecha o similar -> value como hash de la cookie(?)

Hardware & Energy:
------------------
1º      ---- Configurations
2º      ---- Save batery mode (soft, medium, hard)
3º DONE ---- Sensor install
4º      ---- conect sensor with system
5º      ---- si esta en modo ahorro de energia 2, el scp tiene que activar el wifi, enviar las cosas y desactivarlo o esperar a una de las franjas en que el wifi está activado y enviar todos los ficheros que no envió antes. Preguntar a kolar cual es el mejor método o cual prefiere.

Last Meeting Kolar
------------------
1º conectar a red wifi
2º portar server
3º obtener ip visible
4º conectar sensor
5º power saving modes

* Tres modos de batería, el primero con wifi activado, el segundo activar el wifi sólo cuando el usuario quiera segun franjas horarias, dias, etc. El tercer modo apaga la raspberri y el reloj del sensor la despierta antes de cada medida, si es franja horaria del 2º modo o del 1º cambia a ese modo. Poner opciones en configuracion para esto. Poner de gratis opcion "siempre modo 1" no siempre modo 3 porque no podría cambiarse de modo. Al poner modo 3 setear una fecha obligatoria para pasar a modo 2 o modo 1 ya que sino no se podría despertar al cacharro.

* Por otro lado kolar dijo que como modo de obtener puntuacion extra crear un script que desde el cliente permita pedir a la raspi los valores que no están almacenados en el ordenador de kolar. simplemente generar una conexion scp que antes de nada mire en el directorio expecificado cual es la ultima muestra y que pida todos los ficheros desde entonces. Tambien podria mirarse un diff, que traiga todos los intervalos faltantes o a lo guarro que traiga todo sobrescribiendo los que ya estan mediante los buckup almacenados en la raspi.

* El Wifi para tener ip visible consiste en el dhcp pasarle el nombre correcto tipo usuarioVut~nombrednscorto.fit.vutbrno.cz hay que investigar sobre esto porque no lo tengo del todo claro pero siempre puedo preguntar a los técnicos o a los colleges de la oficina.
	- http://www.stud.fit.vutbr.cz/~user/
	- AMEND el user es dhcps<ipnum>

Pass:
-----
pi
tarifni zona sto jedna

Web Pass:
---------
weatherman
rainypiday

Daemon bones:
-------------

quieto
a ver
tu tienes el daemon escrito en python
tipo
a ver que te hago el pseudo
import pollas_en_vinagre
import os

class KawaiiTermometerDaemon: 

  def __init__(self): 
    self.is_kawaii = False
    pass = raw_input("Metemela: ")
    if not self.comprobar_pass_con_fichero_cifrado(pass): 
      print "Vas a hackear a tu puta madre"
      return
    else: 
      self.funcionando()
    
  def funcionando(self): 
    while True:
      self.hacer_cosas()
      os.sleep(5*60)

*Creacion de un cron
cron = CronTab(user='coke') #TODO change user in RPI2
job  = cron.new(command='./scp.py') #TODO arguments here
job.hour.every(int(form["scpfrequency"].value))

cifrado de usuarios en raspi
-----------------------------

jajaja
lo que tambien se me ocurre es cifrar la contraseña de cifrado de los datos con las contraseñas de los usuarios, y guardar los reusltados en un txt
es guarro, guarro, guarro
el usuario loguea, el sistema comprueba que está bien, y coge esa pass para descifrar la hash de la contraseña a los datos
serian dos txt, uno para usuario hash para el login, y el otro con usuario - contraseña de datos cifrada
o dos sqlite

WPA_SUPLICANT
-------------
En /etc/wpa_supplicant/supplicant.conf

country=GB
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
network={
        ssid="eduroam"
        eap=TTLS
        key_mgmt=WPA-EAP
        anonymous_identity=""
        identity=""
        password=""
        phase2="auth=PAP"
}

* Activar ssh

PAssword encriptation
---------------------
>>> from Crypto.Cipher import AES
>>> obj = AES.new('This is a key123', AES.MODE_CBC, 'This is an IV456')
>>> message = "The answer is no"
>>> ciphertext = obj.encrypt(message)
>>> ciphertext
'\xd6\x83\x8dd!VT\x92\xaa`A\x05\xe0\x9b\x8b\xf1'
>>> obj2 = AES.new('This is a key123', AES.MODE_CBC, 'This is an IV456')
>>> obj2.decrypt(ciphertext)

Passsword Hash
--------------

import hashlib
hash_object = hashlib.sha256(b'Hello World')
hex_dig = hash_object.hexdigest()
print(hex_dig)
